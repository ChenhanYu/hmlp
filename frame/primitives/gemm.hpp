/**
 *  HMLP (High-Performance Machine Learning Primitives)
 *  
 *  Copyright (C) 2014-2017, The University of Texas at Austin
 *  
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *  
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 *  GNU General Public License for more details.
 *  
 *  You should have received a copy of the GNU General Public License
 *  along with this program. If not, see the LICENSE file.
 *
 **/  



#ifndef GEMM_HPP
#define GEMM_HPP

#include <hmlp.h>
#include <hmlp_base.hpp>
/** Use matrix view to employ SuperMatrix style task parallelism. */
//#include <View.hpp>

using namespace std;
using namespace hmlp;

namespace hmlp
{
namespace gemm
{

template<typename T>
class xgemmTask : public Task
{
  public:

    T alpha = 0.0;

    View<T> A;

    View<T> B;

    T beta = 0.0;

    View<T> C;

    hmlpError_t Set( 
        T alpha, View<T> &A,
                 View<T> &B,
        T beta,  View<T> &C )
    {
      /** main arguments  */
      this->alpha = alpha;
      this->A = A;
      this->B = B;
      this->beta = beta;
      this->C = C;

      /** name and label */
      ostringstream ss;
      name = string( "gemm" );

      /** Flops, mops, cost and event */
      double flops = 0.0, mops = 0.0;
      cost  = 2.0 * C.row() * C.col();
      event.Set( name + label, flops, mops );
      return HMLP_ERROR_SUCCESS;
    };

    hmlpError_t DependencyAnalysis()
    {
      /** Read A and B, read/write C */
      A.DependencyAnalysis( R,  this );
      B.DependencyAnalysis( R,  this );
      C.DependencyAnalysis( RW, this );
      assert( !this->TryEnqueue() );
      return HMLP_ERROR_SUCCESS;
    };

    hmlpError_t Execute( Worker* user_worker )
    {
      string transA, transB;
      if ( A.IsTransposed() ) transA = "Transpose";
      else                    transA = "No transpose";
      if ( B.IsTransposed() ) transB = "Transpose";
      else                    transB = "No transpose";

      size_t m = C.row();
      size_t n = C.col();
      size_t k = A.col();

      assert( A.row() == m );
      assert( B.row() == k );
      assert( B.col() == n );

      //int rand_id = rand();

      //printf( "%d GEMM task %s %s %lu %lu %lu, %E, %E\n", 
      //    rand_id, transA.data(), transB.data(), m, n, k, alpha, beta ); fflush( stdout );
      //printf( "%d lda %lu ldb %lu ldc %lu\n", rand_id, A.ld(), B.ld(), C.ld() ); fflush( stdout );

      xgemm( transA.data(), transB.data(), m, n, k,
        alpha, A.data(), A.ld(),
               B.data(), B.ld(),
        beta,  C.data(), C.ld() );

      //printf( "%d end GEMM task %s %s %lu %lu %lu, %E, %E\n", 
      //    rand_id, transA.data(), transB.data(), m, n, k, alpha, beta ); fflush( stdout );
      return HMLP_ERROR_SUCCESS;
    };

}; /** end class xgemmTask */


/**
 *  @brief  This task is generated by the top level routine.
 **/
template<typename T>
class xgemmBarrierTask : public Task
{
  public:

    View<T> C;

    hmlpError_t Set(T alpha, View<T> &A, View<T> &B, T beta,  View<T> &C) 
    {
      /** Main arguments */
      this->C = C;
      this->stealable = false;

      /** Name and label */
      name = string( "gemmBarrier" );

      /** Flops, Mops, cost and event */
      double flops, mops;
      flops = 0.0;
      mops  = 0.0;
      cost  = 1.0;
      event.Set( name + label, flops, mops );
      return HMLP_ERROR_SUCCESS;
    };

    /** Create RAW dependencies on all submatrices C. */
    hmlpError_t DependencyAnalysis() 
    {
      C.DependencyAnalysis( RW, this ); 
      return HMLP_ERROR_SUCCESS;
    };

    hmlpError_t Execute( Worker* user_worker ) 
    {
      return HMLP_ERROR_SUCCESS;
    };

}; /** end class xgemmBarrierTask */


template<typename T>
void CreatexgemmTask( T alpha, View<T> &A, View<T> &B, T beta,  View<T> &C )
{
  auto *task = new xgemmTask<T>();
  task->Set( alpha, A, B, beta, C );
  task->Submit();
  task->DependencyAnalysis();
}; /** end xgemmTask() */


/**
 *  @brief
 */ 
template<size_t NB = 512, typename T>
void xgemm_var1( T alpha, View<T> &A, View<T> &B, T beta,  View<T> &C )
{
  /** All subviews */
  View<T> AL, AR, 
          A0, A1, A2;
  View<T> BT, BB, 
          B0, B1, B2;
  /** A = [ AL, AR ] */
  A.Partition1x2( AL, AR, 0, LEFT );
  /** B = [ BT; BB ] */
  B.Partition2x1( BT,
                  BB,     0, TOP  ); 

  //printf( "AL.col() %lu AR.col() %lu A.col() %lu\n", AL.col(), AR.col(), A.col() );

  while ( AL.col() < A.col() )
  {
    //printf( "AL.col() %lu AR.col() %lu A.col() %lu\n", AL.col(), AR.col(), A.col() );
    size_t b = std::min( AR.col(), NB );

    /** Repartition A */
    Repartition1x2To1x3( AL,      AR,
                         /** **** */
                         A0,  A1, A2, b, RIGHT );
    /** Repartition B */
    Repartition2x1To3x1( BT, /**/ B0,
                             /**/ B1,
                         BB, /**/ B2, b, BOTTOM );

    /** --------------------------------------------------- */
    CreatexgemmTask( alpha, A1, B1, beta, C );
    beta = 1.0;
    /** --------------------------------------------------- */

    /** Merge A */
    ContinueWith1x3To1x2( AL,      AR,
                          /** **** */
                          A0,  A1, A2, LEFT );
    /** Merge B */
    ContinueWith3x1To2x1( BT, /**/ B0,
                              /**/ B1,
                          BB, /**/ B2,  TOP );

  } /** end while */
}; /** end xgemm_var1() */


/** @brief [ A * BL + CL, A * BR + CR ] */ 
template<size_t NB = 512, typename T>
void xgemm_var2( T alpha, View<T> &A, View<T> &B, T beta,  View<T> &C )
{
  /** All subviews */
  View<T> CL, CR, 
          C0, C1, C2;
  View<T> BL, BR, 
          B0, B1, B2;
  
  C.Partition1x2( CL, CR, 0, LEFT );
  B.Partition1x2( BL, BR, 0, LEFT );

  while ( BL.col() < B.col() )
  {
    size_t b = std::min( BR.col(), NB );

    /** Repartition C */
    Repartition1x2To1x3( CL,      CR,
                         /** **** */
                         C0,  C1, C2, b, RIGHT );
    /** Repartition B */
    Repartition1x2To1x3( BL,      BR,
                         /** **** */
                         B0,  B1, B2, b, RIGHT );

    /** --------------------------------------------------- */
    xgemm_var1( alpha, A, B1, beta, C1 );
    /** --------------------------------------------------- */

    /** Merge C */
    ContinueWith1x3To1x2( CL,      CR,
                          /** **** */
                          C0,  C1, C2, LEFT );
    /** Merge B */
    ContinueWith1x3To1x2( BL,      BR,
                          /** **** */
                          B0,  B1, B2, LEFT );

  } /** end while */
}; /** end xgemm_var2() */


/** @brief [ AT * B + CT; AB * B + CB ] */ 
template<size_t NB = 512, typename T>
void xgemm_var3( T alpha, View<T> &A, View<T> &B, T beta,  View<T> &C )
{
  /** All subviews */
  View<T> AT, A0, CT, C0, 
          AB, A1, CB, C1,
              A2,     C2;

  A.Partition2x1( AT,
                  AB,     0, TOP  ); 
  C.Partition2x1( CT,
                  CB,     0, TOP  ); 

  while ( AT.row() < A.row() )
  {
    size_t b = std::min( AB.row(), NB );

    /** Repartition A */
    Repartition2x1To3x1( AT, /**/ A0,
                             /**/ A1,
                         AB, /**/ A2, b, BOTTOM );
    /** Repartition B */
    Repartition2x1To3x1( CT, /**/ C0,
                             /**/ C1,
                         CB, /**/ C2, b, BOTTOM );

    /** --------------------------------------------------- */
    xgemm_var2( alpha, A1, B, beta, C1 );
    /** --------------------------------------------------- */

    /** Merge A */
    ContinueWith3x1To2x1( AT, /**/ A0,
                              /**/ A1,
                          AB, /**/ A2,  TOP );
    /** Merge C */
    ContinueWith3x1To2x1( CT, /**/ C0,
                              /**/ C1,
                          CB, /**/ C2,  TOP );
  }; /** end while */
}; /** end xgemm_var3() */


/** @breif  Interface for automatic task-bsed parallelism. */ 
template<size_t NB = 512, typename T>
void xgemm( T alpha, View<T> &A, View<T> &B, T beta,  View<T> &C )
{
  string transA = A.IsTransposed() ? "Transpose" : "No transpose";
  string transB = B.IsTransposed() ? "Transpose" : "No transpose";
  size_t m = C.row();
  size_t n = C.col();
  size_t k = A.col();
  assert( A.row() == m );
  assert( B.row() == k );
  assert( B.col() == n );
  hmlp::xgemm( transA.data(), transB.data(), m, n, k,
    alpha, A.data(), A.ld(),
           B.data(), B.ld(),
    beta,  C.data(), C.ld() );
  return;

  /** TODO: THE FOLLOWING NESTED PARALLEL GEMM WILL RESULT IN MEMORY LEAK. */
  A.CreateLeafMatrixBlocks( NB, NB );
  B.CreateLeafMatrixBlocks( NB, NB );
  C.CreateLeafMatrixBlocks( NB, NB );

  /** Call back */
  if ( hmlp_is_in_epoch_session() )
  {
    auto *begXGEMMtask = new xgemmBarrierTask<T>();
    auto *endXGEMMtask = new xgemmBarrierTask<T>();
    /** 
     *  The reason why we need the begin barrier
     *  task is to ensure the whole DAG will be
     *  inserted at once. Otherwise, the dependent
     *  task may not be created while the traversal
     *  has already reached by other workers.
     *
     *  The solution is to create a beginning barrier
     *  such that all the following tasks depend on it.
     *  Only enqueue the beginning barrier while all
     *  dependent tasks have been created.
     */
    begXGEMMtask->Set( alpha, A, B, beta, C );
    begXGEMMtask->Submit();
    begXGEMMtask->DependencyAnalysis();

    /**
     *  Now we create all dependent tasks. Since they
     *  all dependent on begXGEMMtask. They all have
     *  STATUS=NOTREADY. Thus, no one will be enqueued.
     */ 
    xgemm_var3( alpha, A, B, beta, C );

    /**
     *  Create a termination barrier such that it depends
     *  on all tasks.
     */ 
    endXGEMMtask->Set( alpha, A, B, beta, C );
    endXGEMMtask->Submit();
    endXGEMMtask->DependencyAnalysis();

    /** Now enqueue begXGEMMtask and callback with endXGEMMtask. */
    begXGEMMtask->TryEnqueue();
    endXGEMMtask->CallBackWhileWaiting();
  }
  else
  {
    xgemm_var3( alpha, A, B, beta, C );
  }
}; /** xgemm() */


template<typename T>
void xgemm( hmlpOperation_t transA, hmlpOperation_t transB,
    T alpha, Data<T> &A, Data<T> &B, T beta,  Data<T> &C ) 
{
  const bool TRANS = true;
  const bool NOTRANS = true;

  /** Matrix views of A, B and C */
  View<T> Aview, Bview, Cview;

  /** A and B may be in tranpose view */
  if ( transA == HMLP_OP_T ) Aview.Set(  true, A );
  else                       Aview.Set( false, A );
  if ( transB == HMLP_OP_T ) Bview.Set(  true, B );
  else                       Bview.Set( false, B );
  /** C is always not transpose */
  Cview.Set( C );

  xgemm( alpha, Aview, Bview, beta, Cview );
  
}; /** end xgemm() */


template<typename T>
void xgemm( T alpha, Data<T> &A, Data<T> &B, T beta,  Data<T> &C ) 
{
  xgemm( HMLP_OP_N, HMLP_OP_N, alpha, A, B, beta, C );
}; /** end xgemm() */




}; /** end namespace gemm */
}; /** end namespace hmlp */


#endif /** define GEMM_HPP */
